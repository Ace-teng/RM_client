# RoboMaster 自定义客户端 系统需求与架构设计文档

**（System Requirements & Architecture Specification）**

> **本文档为需求与架构之唯一总文档，后续更新均在此进行。**

| 版本 | 作者 | 日期 | 状态 |
|------|------|------|------|
| v1.0 | 田志腾 | 2026 | Architecture Baseline |

**适用对象：** 开发人员 / 继任成员 / 系统维护者  

**项目仓库：** [https://github.com/Ace-teng/RM_client](https://github.com/Ace-teng/RM_client)

**约束：** 本文件是项目最高级技术约束文档。**任何实现不得违反本文档中标记为 MUST 的条款。**

**技术选型：** 本客户端**界面与交互采用 QtPy 开发**。QtPy 统一封装 PyQt5 / PyQt6 / PySide2 / PySide6，便于在 Qt 绑定间切换，保证跨平台与长期可维护；业务逻辑、通信与协议层使用 Python 标准库及第三方库（见下）。

---

## 0. 技术选型与基本功能

### 0.1 技术栈（Tech Stack）

| 类别 | 选型 | 说明 |
|------|------|------|
| **UI 框架** | **QtPy** | 主窗口、图传区、控制面板、HUD、标定与诊断界面等均基于 QtPy；禁止在表现层混用其他 GUI 库。 |
| **语言** | Python 3.10+ | 推荐 3.10 及以上，便于类型注解与异步。 |
| **赛事通信** | paho-mqtt + protobuf | MQTT 订阅/发布、Protobuf v3 序列化/反序列化。 |
| **图传** | UDP socket + HEVC 解码库 | 端口 3334、8 字节包头；解码与渲染由 QtPy 与底层解码库配合。 |
| **设备间通信** | socket（UDP/TCP）或串口等 | **仅对赛事规则明确允许的设备**（如雷达站等）可与本客户端建立局域网链路。**车端**与官方裁判系统 UART 双向通信，**官方裁判系统服务器**将数据**分发到各客户端**，本客户端经 MQTT/图传 接收。**自定义客户端彼此**不得自建局域网，须经官方服务器数据链路。**自定义客户端与自定义控制器**：规则允许**自行有线通信**，具体方式（串口/有线以太网等）规则未限定，由队伍实现。 |
| **数据与事件** | DataCenter 单例 + 事件总线 | 状态集中存储；模块间通过事件总线解耦，可选 QtPy signals/slots。 |

### 0.2 基本功能总览（保证最终开发成果可用）

以下为客户端必须具备的基本功能，实现与验收须覆盖。

| 功能域 | 基本功能 | 对应章节 |
|--------|----------|----------|
| **赛事数据** | 接收赛事引擎 MQTT（Protobuf）、订阅/发布对应 Topic；向赛事引擎发送指令（性能体系、发弹量、空中支援等）。 | 1.5、4.1、5.2.1 |
| **图传** | 接收 UDP 3334、8 字节包头解析、HEVC 解码与显示；图传区为界面中心。 | 1.5、4.1、4.2、5.1、5.1.4 |
| **态势与状态** | 双方血量、经济、时间、比赛事件、连接状态；地图、机器人位置、关键状态展示。 | 5.1、4.5、7 Phase 5 |
| **透视框（HUD）** | 多目标框、标签、附加信息；总开关/调试开关、超时隐藏、断流自动消失；框稳定跟随。 | 5.1.1、5.1.4 |
| **标定** | 标定页面入口（进入/退出、重试）、状态四态、失败原因与最近结果、ArUco 引导；状态实时刷新、失败可重试、成功明确确认。 | 5.1.2、5.2.2 |
| **雷达与设备间** | 在赛事规则允许的前提下，雷达站等设备可与本客户端 LAN 接入（UDP/TCP）；重连、心跳、丢包/延迟/带宽/最近更新时间统计；雷达位姿、透视框坐标等数据接入。车端与官方裁判系统 UART 双向通信，官方裁判系统服务器将相关内容分发到各客户端；自定义客户端彼此不得自建 LAN，须经官方服务器。自定义客户端与自定义控制器：规则允许自行有线通信，具体方式规则未限定，由队伍实现。 | 5.2.1、4.1、10.4 |
| **诊断与联调** | 连接状态、数据状态、最近更新时间（多久前更新）；丢弃/超时计数；一键复制诊断信息；快速判断状态。录包与离线回放（可选）。 | 5.1.3、5.2.5、8 |
| **控制与扩展** | 控制面板发送赛事指令；插件机制，新功能优先以插件实现。 | 5.1、4.6、7 Phase 6–7 |

### 0.3 按本文档开发后得到的最终产品形态描述

以下描述按本总文档实现后，**最终产品是什么样子**，供实现与验收对照。

**一、整体形态**

- **类型**：桌面端应用程序（QtPy 窗口程序），运行在操作间的一台运算设备上（PC 或带网口的平板等）。
- **角色**：多设备战术信息中枢——接入赛事引擎（即官方裁判系统服务器，经 MQTT + 图传 UDP 分发到各客户端）、在规则允许时接入雷达站等，并可自行与自定义控制器有线通信（方式规则未限定），在一个界面上完成图传观看、态势感知、标定、诊断与赛事指令下发。车端与官方裁判系统 UART 双向通信；自定义客户端彼此不直连，须经官方服务器。自定义控制器定义及与客户端有线通信见 §1.5。
- **部署**：通过 RJ45 有线接赛事引擎（192.168.12.1，即官方裁判系统服务器）；客户端 IP 由 DHCP 分配。在规则允许时与**雷达**等设备可 LAN（UDP/TCP）；本客户端可与**自定义控制器**自行**有线**连接（具体方式规则未限定）。**自定义客户端之间**不得自建局域网，须经官方服务器数据链路。**车端**与官方裁判系统通过 UART 串口**双向通信**；**官方裁判系统服务器**将赛事数据与图传等**分发到各个客户端**，本客户端经 MQTT/图传 接收。

**二、主界面布局（用户一眼看到的）**

- **主窗口**：QtPy QMainWindow，带标题栏、菜单栏（若有）、状态栏。
- **中心区域**：大块图传显示区（QGraphicsView），实时显示机器人图传（HEVC 解码后画面）；上面可叠加透视框（多目标框、标签、附加信息），有总开关和调试开关，框可超时隐藏、断流自动消失、稳定跟随目标。
- **右侧**：控制面板——赛事指令（性能体系选择、兑换发弹量、空中支援等）、透视框/标定等功能的开关与入口；可展示双方血量、经济、时间、比赛事件、连接状态等。
- **状态栏或诊断区**：连接状态、数据状态、最近更新时间（「多久前更新」）、丢弃/超时计数；支持一键复制诊断信息、可选一键导出日志，便于快速判断链路与数据是否正常。

**三、主要使用场景与体验**

| 场景 | 用户操作与看到的结果 |
|------|----------------------|
| **看比赛** | 中心区实时图传 + 叠加的透视框（若开启）；右侧/状态栏有血量、经济、时间、事件；连接与数据状态清晰，异常有计数与「多久前更新」。 |
| **发指令** | 在控制面板选择/点击赛事指令（性能体系、发弹量、空中支援等），客户端通过 MQTT 向赛事引擎发送，无需官方选手端即可完成操作。 |
| **标定** | 通过入口进入标定页面；有进入/退出、重试；状态四态（未开始/进行中/成功/失败）、失败原因与最近结果；对准同一 ArUco、等待标定完成的引导文案；状态实时刷新、失败可重试、成功有明确确认。 |
| **联调与排错** | 查看链路状态、数据状态、丢弃/超时计数；一键复制诊断信息给队友或日志；可选录包与离线回放，无机器人也能调试。 |
| **多设备协同** | 后台接入官方裁判系统服务器（MQTT/图传），在规则允许时接入雷达等（LAN），并可自行与自定义控制器有线通信（方式未限定）；自定义客户端彼此经官方服务器、不自建 LAN。透视框与态势数据可来自雷达或裁判系统分发数据；坐标与时间由系统统一管理，框与地图不漂移、不错位。 |

**四、非界面侧（用户不直接看到但保证可用）**

- **数据流**：赛事与设备间数据经 comms → protocol → DataCenter → service → ui，单向、不逆向；状态只存 DataCenter，无私有缓存，界面不卡顿、状态不乱。
- **扩展**：新功能优先以插件实现，主程序稳定；支持长期维护与跨届交接。

**五、一句话总结**

按本文档开发完成后，得到的是一套**以 QtPy 为界面的 RoboMaster 自定义客户端桌面程序**：中心是图传 + 可开关的透视框，右侧是控制与状态，具备赛事数据接收与指令发送、标定、诊断与设备间接入能力，数据与时间统一管理，可维护、可交接、可扩展。

### 0.4 多屏 / 多角色视图（待定）

**问题：** 不同队员（如雷达手、地面机器人手）是否应使用**不同的屏幕或界面布局**？

**可能形态：**

| 方案 | 说明 |
|------|------|
| **单屏 + 视图切换** | 同一主窗口内，按角色切换「雷达视图」「地面视图」等，布局/控件不同，数据仍来自同一 DataCenter。 |
| **多物理屏** | 一台主机接多台显示器，不同屏显示不同内容（如屏 1 图传+透视框，屏 2 雷达/态势，屏 3 控制/诊断）；或同一程序多窗口拖到不同屏。 |
| **多实例/多窗口** | 同一进程内多个 QMainWindow 或 QWidget 窗口，各自侧重（雷达、地面、综合），可拖到不同显示器。 |

**当前约定：** 本总文档**不强制**多屏或多角色视图；默认描述为「单主窗口 + 中心图传 + 右侧控制面板」。若队伍后续确定「雷达手 / 地面手等使用不同屏或不同视图」，可按产品决策在 **ui 层** 增加：

- **视图模式**：主窗口内切换布局（如雷达模式、地面模式、综合模式），或  
- **多窗口**：从同一 DataCenter 与事件总线读取，不同窗口展示/操作不同子集，

**不破坏**现有分层与数据流（R-ARCH-001/002/003 仍成立）。

**建议：** 产品与操作手确认需求后，将「是否多屏/多角色视图、采用哪种方案」写入本节或第 5 章，再在 Phase 4/5 之后安排实现。

### 0.5 角色需求：地面机器人操作手

以下为**地面机器人操作手**使用客户端时的典型需求，实现与多角色视图（§0.4）设计时须覆盖。

**核心诉求：** 以己方地面机器人视角为主，看图传、看己方/对方状态、快速发赛事指令，兼顾态势与诊断；界面信息突出「己车/己方」，操作路径短、延迟可感知。

| 需求类别 | 具体需求 | 对应文档 |
|----------|----------|----------|
| **图传** | 以**己方地面车图传**为主视；若有多台地面车，支持**图传源切换**（看哪台车的画面）。图传延迟与断流可感知（诊断区/状态提示）。 | 5.1、5.1.4、5.1.3 |
| **己方状态** | **己方血量、经济、发弹量、剩余时间**、比赛阶段与关键事件；可突出己车或己方关键数据，便于操作手快速判断局势。 | 5.1 状态展示、0.2 基本功能 |
| **态势** | 己方与对方**位置/态势**（若来自雷达或裁判数据）；小地图或态势图，便于配合决策与走位。 | 5.1、5.2.1、7 Phase 5 |
| **赛事指令** | **快速入口**下发性能体系选择、兑换发弹量、空中支援等；操作路径短、误触少（如二次确认或权限）。 | 5.1 控制面板、1.4 本项目目标 |
| **透视框** | 若雷达/视觉提供己方视角的透视框，需**稳定叠加在图传上**；框稳定跟随、断流自动消失、可开关。 | 5.1.1、5.1.4 |
| **诊断** | **图传/数据连接状态**、延迟、丢包；可快速判断「车端掉了」还是「裁判系统掉了」，便于联调与赛场排错。 | 5.1.3、R-COM-005 |

**与多屏/多角色关系：** 若采用 §0.4 的视图切换或多窗口，**地面手视图**建议侧重：中心为己方图传 + 透视框，右侧为己方状态 + 赛事指令面板，状态栏/诊断区可见链路与数据状态；与「雷达手视图」「综合视图」等区分布局与信息密度。

**验收时可对照：** 地面操作手能否在单屏（或地面手专用视图）上完成「看图传 → 看己方/对方状态 → 发赛事指令」主流程，且图传源可选、诊断可快速判断链路问题。

---

## 1. 引言与目标

### 1.1 目的

本文档定义 RoboMaster 自定义客户端的**完整系统需求与架构边界**，用于：

- **指导**从 0 到 1 的系统实现
- **约束**后续开发行为
- **保证**跨届维护可持续性
- **防止**架构失控或功能耦合

### 1.2 系统定位

本客户端并非单机 GUI 程序，而是**多设备战术信息中枢（Tactical Information Hub）**，属于**分布式实时通信 + 可视化系统**。

系统需同时承担：官方裁判系统数据接入（MQTT + 图传，车端与官方裁判系统 UART 双向通信，官方裁判系统服务器将相关内容分发到各客户端）、图传显示、雷达数据融合、车端信息（经裁判系统分发）接入、在规则允许时与雷达等 LAN 通信及与自定义控制器有线通信（方式规则未限定）、战术可视化（HUD、态势图、控制面板）。

### 1.3 自定义客户端定义（赛事规范）

根据 RoboMaster 赛事规则，**自定义客户端**是参赛队伍自制的多用途设备，用于：

- **接收**赛事引擎服务器发送的比赛相关信息与机器人图传画面；
- **发送**赛事专用交互指令至赛事引擎服务器；
- **拓展**人机交互可能性，使队伍可不依赖官方裁判系统选手端完成比赛。

典型形态：显示设备 + 运算平台（存储器、控制器、运算器）+ 输入设备；或一体化设备（如带网口的手持平板）。通过操作间 RJ45 有线接入赛事引擎服务器，与自定义控制器可有线通信。

### 1.4 本项目目标

- 接收赛事引擎服务器赛事数据（MQTT + Protobuf）、机器人图传（UDP，HEVC）
- 展示比赛信息与态势感知（双方血量、己方经济、剩余时间、关键事件播报等）
- 发送选手端支持的赛事指令（赛前性能体系选择、赛中兑换发弹量、空中支援等）
- 支持功能扩展与长期维护、多届成员持续迭代开发

系统须满足：**Maintainability / Extensibility / Modularity / Decoupling / Readability**。**本项目定位为队伍长期基础设施，而非一次性工具软件。**

### 1.5 赛事通信规范（与规则一致）

| 项目 | 规范 |
|------|------|
| 数据格式 | Protobuf v3（Protocol Buffers） |
| 赛事数据传输 | MQTT 发布/订阅，直接传输 Protobuf 序列化二进制流 |
| Topic | 对应指令/消息名（见赛事通信协议文档） |
| 赛事引擎服务器 | 固定 IP：192.168.12.1，端口：3333 |
| 自定义客户端 IP | DHCP 自动分配 |
| 图传 | UDP 监听端口 **3334**，编码格式 **HEVC** |

**车端与官方裁判系统、客户端的关系：** 车端（机器人）**不能**与客户端直连局域网。车端与**官方裁判系统**通过**裁判系统提供的 UART 串口**进行**双向通信**；**官方裁判系统服务器**将赛事数据、图传等相关内容**分发到各个客户端**（含官方选手端、自定义客户端等），经 MQTT（3333）与 UDP 图传（3334）下发。因此本客户端只需实现与官方裁判系统服务器（赛事引擎）的 MQTT + 图传 链路，无需与车端建立 UDP/TCP 连接。

**自定义客户端之间不得自建网络：** 赛事**不允许队伍独立架设一套与赛事无关的局域网**。**自定义客户端彼此之间也不能通过自建局域网直连**；若需交换数据，须**经官方裁判系统服务器的数据链路**（如 MQTT 订阅/发布、或协议允许的其它方式），不得在多个自定义客户端之间私建 UDP/TCP 等独立网络。具体以当届《RoboMaster 机甲大师高校系列赛通信协议》及赛事规则为准。

**自定义控制器（Custom Controller）的定义与通信：** **自定义控制器**在赛事中通常指队伍自制的**输入/控制设备**（如自定义操作面板、摇杆、按键盒等），用于在比赛时与**选手端**或**机器人**进行数据交互，以拓展人机交互方式。根据裁判系统串口协议，自定义控制器通过**裁判系统提供的串口**与裁判系统连接，经裁判系统转发与选手端（如 0x0306 与选手端交互）、与机器人（如 0x0302 与图传连接的机器人交互）通信。**自定义客户端与自定义控制器**：规则**允许**自定义客户端**自行**与自定义控制器进行**有线通信**；规则**未规定具体实现方式**（仅明确为有线），具体采用串口、USB、有线以太网等由队伍自行实现，本客户端在设备间链路中预留与自定义控制器的有线连接能力（实现方式待定）。

**MQTT 通信流程：** 按赛事文档编写 `.proto` → `protoc` 生成代码 → 发布端序列化 → MQTT publish 到 Topic → 订阅端 Protobuf 反序列化。

**图传 UDP 包格式：** 每个 UDP 包码流数据前 **8 字节** 固定为：帧编号（2 byte）、当前帧内分片序号（2 byte）、当前帧总字节数（4 byte）；之后为 HEVC 码流。实现时需按此包头做分片重组与解码。

**参考赛事文档：** 《RoboMaster 机甲大师高校系列赛通信协议》（当届版本，如 2026 通信协议 V1.1.0）；《附录三：自定义客户端示例通信代码》。网络与设备连接约束（自定义客户端彼此、自定义控制器与客户端等）以当届通信协议及赛事规则为准。

---

## 2. 总体架构要求（MUST）

| 需求 ID | 名称 | 约束 | 内容 |
|---------|------|------|------|
| **R-ARCH-001** | 分层架构 | MUST | 系统必须采用六层设计：通信层、协议层、数据层（DataCenter）、业务层、表现层、插件层。禁止跨层直接依赖。 |
| **R-ARCH-002** | 单一数据源 | MUST | 所有比赛状态数据必须集中存储于 DataCenter。禁止：UI 保存副本、模块私有缓存、多处状态源。 |
| **R-ARCH-003** | 单向数据流 | MUST | 数据流方向必须为：**通信 → 协议 → 数据 → 业务 → UI**。不得逆向。 |

**六层说明：**

| 层级 | 英文名 | 说明 |
|------|--------|------|
| 通信层 | Communication Layer | 网络收发（赛事 MQTT/UDP + 设备间 LAN） |
| 协议层 | Protocol Layer | 协议解析与分发 |
| 数据层 | DataCenter | 状态存储与访问（唯一数据源） |
| 业务层 | Service Layer | 战术、报警、融合、推理 |
| 表现层 | Presentation Layer | 展示与交互 |
| 插件层 | Plugins Layer | 扩展功能、试验性模块 |

**其他原则：** 职责单一（通信不解析协议、协议不涉及 UI、UI 不含算法）；可扩展（新功能通过模块/插件实现，不修改核心代码）；可交接（目录清晰、命名规范、文档齐全、无隐式逻辑）。

---

## 3. 系统目录结构

项目目录固定如下，**禁止随意更改层级**：

```
rm_client/
├── main.py
├── core/
│   ├── comms/      # 通信层（赛事 + 设备间）
│   ├── protocol/      # 协议层
│   ├── model/      # 数据层（DataCenter）
│   ├── service/    # 业务层
│   ├── bus/        # 事件总线（R-BUS-*）
│   ├── pose/       # 坐标系与标定（R-POSE-*）
│   ├── time_sync/  # 时间同步（R-TIME-*）
│   └── replay/     # 录包与回放（R-DBG-*）
├── ui/
│   ├── hud/        # 叠加显示
│   ├── radar/      # 态势地图
│   └── control/    # 操作面板
├── plugins/        # 插件层
├── config/
└── docs/
```

---

## 4. 模块职责定义

### 4.1 comms（通信层）

**基本职责：**

- **赛事链路**：MQTT（192.168.12.1:3333）订阅/发布、收发 Protobuf 二进制流；UDP 图传 3334、接收带 8 字节包头的 HEVC 包；向赛事引擎发送指令二进制流。
- **设备间链路**（R-COM-*）：**仅对赛事规则明确允许的设备**（如雷达站）可与本客户端建立局域网 UDP/TCP；**自定义客户端与自定义控制器**规则允许**自行有线通信**，具体方式（串口/有线以太网等）规则未限定，由队伍实现。上述链路的单向/双向发送、自动重连、心跳检测、丢包率/延迟/带宽/最近更新时间统计；可选消息序列号与乱序重排。**车端、自定义客户端彼此**无 LAN 直连——车端与官方裁判系统 UART 双向通信，官方裁判系统服务器向各客户端分发；自定义客户端之间不得自建 LAN，须经官方服务器。详见 §1.5。

**输入/输出：** 输入为网络字节流（MQTT 消息体、UDP 包）；输出为原始字节流（按 Topic/端口/来源区分，**不解析业务内容**）。**禁止：** 协议解析（含 Protobuf、图传包头）、状态存储、UI 调用。

### 4.2 protocol（协议层）

**基本职责：** Protobuf v3 反序列化、按 Topic 分发、图传 8 字节包头解析与 HEVC 帧重组；将 comms 输出的字节流转为结构化对象（以赛事协议为准），写入 DataCenter 或交给事件总线。

**输入/输出：** 输入为 comms 层原始字节（带 Topic/端口标识）；输出为结构化对象（GameState、RobotState、图传帧等）。**禁止：** 网络连接、UI 操作、业务逻辑。

### 4.3 model（数据层）

**基本职责：** 存储所有比赛实时状态、提供统一读写接口、作为全局数据中心；单例、线程安全、支持订阅通知（Signal/Observer 或 QtPy signals）。

**示例字段（与基本功能对应）：** `game_state`（赛事状态）、`robot_states`（机器人状态）、`events`（比赛事件）、`video_frame`（图传帧）、`overlay_boxes`（透视框数据）、`calibration_result`（标定结果）、`link_status`（链路/诊断状态）。**本模块是全系统唯一状态源；** UI 与 service 只读写 DataCenter，禁止私有缓存。

### 4.4 service（业务层）

报警逻辑、战术计算、数据融合、推理与预测。只读写 DataCenter，不操作 UI。

### 4.5 ui（表现层）

界面显示、用户交互、指令触发；**基于 QtPy 实现**（见 §0.1）。子模块：hud、radar、control。**限制：** 不包含算法、不解析协议、只读 DataCenter。功能要求见第 5 章表现层需求。

### 4.6 plugins（插件层）

未来扩展、试验性模块、新策略或新界面。插件独立加载、不修改主程序；**新增功能优先在此实现。**

---

## 5. 功能需求

### 5.1 表现层（Presentation Layer）

| 类别 | 内容 |
|------|------|
| **基础 UI** | 主窗口（QtPy QMainWindow）、中心图传区域（QGraphicsView）、右侧控制面板、状态栏 |
| **HUD 叠加** | 目标框绘制、标签显示、信息叠加、开关控制、实时刷新 |
| **状态展示** | 双方血量、经济、时间、比赛事件、连接状态 |
| **诊断功能** | 丢包统计、延迟统计、一键导出日志 |

**5.1.1 透视框显示（Perspective Box）**

| 子项 | 要求 |
|------|------|
| **显示开关** | 总开关、调试开关；开关即时生效。 |
| **叠加渲染** | 多目标框、目标标签、附加信息；更新覆盖。 |
| **更新与清理** | 超时隐藏、无数据时不显示；断流时框自动消失。 |
| **验收点** | 框稳定跟随；断流自动消失。 |

**5.1.2 标定（Calibration）**

| 子项 | 要求 |
|------|------|
| **页面入口** | 进入/退出按钮、重试按钮；状态四态（如：未开始/进行中/成功/失败）。 |
| **状态展示** | 失败原因短句、最近一次标定结果。 |
| **操作引导** | 对准同一 ArUco 提示、等待标定完成提示。 |
| **验收点** | 状态可实时刷新；失败可重试；成功有明确确认。 |

**5.1.3 诊断与联调**

| 子项 | 要求 |
|------|------|
| **链路状态展示** | 连接状态、数据状态、最近更新时间（含「多久前更新」）。 |
| **异常计数** | 丢弃计数、超时计数（可与 R-COM-005 统计对接）。 |
| **诊断导出** | 一键复制诊断信息（如 QClipboard）；可选一键导出日志。 |
| **验收点** | 可快速判断链路与数据状态。 |

**5.1.4 QtPy 实现约定（与思维导图对齐）**

界面与交互统一使用 **QtPy**（见 §0.1），禁止在表现层混用 Tkinter、wx 等其它 GUI 库。

| 子项 | 要求 |
|------|------|
| **UI 结构** | QtPy 提供：QMainWindow；中心 QGraphicsView（图传区）；右侧控制面板。 |
| **渲染分层** | Scene 底层：VideoLayer（图传）；Scene 上层：OverlayLayer（透视框等）；层之间只通过数据模型联系，禁止跨层直接引用。 |
| **数据模型** | 与 DataCenter 对接的 UI 侧模型建议：FrameModel（图传帧）、BoxModel（目标框）、StatusModel（状态/诊断）；由 DataCenter 或事件总线驱动更新。 |
| **数据驱动** | 后台线程处理收包/解析/写 DataCenter；UI 线程仅做展示与交互；层间通过 QtPy signals/slots 或事件总线通信。 |
| **Overlay 模块** | 建议子组件：BoxStore（框数据）、Renderer（绘制）、TimeoutCleaner（超时隐藏）；与 5.1.1 透视框要求一致。 |
| **诊断模块** | 使用 QtPy QTimer 刷新「多久前更新」；使用 QClipboard 实现一键复制诊断文本。 |

### 5.2 基础设施层（Infrastructure）⭐

以下为系统长期可用性的关键；缺失任意一项，可维护性将显著下降。

**5.2.1 设备间通信（R-COM-*）** — 归属：core/comms

| 需求 ID | 约束 | 内容 |
|---------|------|------|
| R-COM-001 | MUST | 支持局域网 UDP/TCP 通信能力。 |
| R-COM-002 | MUST | 支持单向或双向数据发送。 |
| R-COM-003 | MUST | 支持设备自动重连。 |
| R-COM-004 | MUST | 支持心跳机制检测在线状态。 |
| R-COM-005 | MUST | 统计：丢包率、延迟、带宽、最近更新时间。 |
| R-COM-006 | SHOULD | 支持消息序列号与乱序重排。 |

典型数据类型：雷达位姿矩阵、透视框像素坐标、机器人定位数据。

**5.2.2 坐标系与标定（R-POSE-*）** — 归属：core/pose

| 需求 ID | 约束 | 内容 |
|---------|------|------|
| R-POSE-001 | MUST | 维护统一坐标注册表。 |
| R-POSE-002 | MUST | 支持任意两坐标系间变换计算。 |
| R-POSE-003 | MUST | 支持外参矩阵存储与更新。 |
| R-POSE-004 | MUST | 提供统一接口：`transform(point, src, dst)`。 |
| R-POSE-005 | SHOULD | 支持历史缓存与插值。 |

**5.2.3 消息总线（R-BUS-*）** — 归属：core/bus

| 需求 ID | 约束 | 内容 |
|---------|------|------|
| R-BUS-001 | MUST | 实现统一事件总线。 |
| R-BUS-002 | MUST | 支持 publish/subscribe 模式。 |
| R-BUS-003 | MUST | 模块之间不得直接互相调用。 |

**5.2.4 时间同步（R-TIME-*）** — 归属：core/time_sync

| 需求 ID | 约束 | 内容 |
|---------|------|------|
| R-TIME-001 | MUST | 所有数据必须携带时间戳。 |
| R-TIME-002 | MUST | 系统维护缓冲队列。 |
| R-TIME-003 | MUST | 支持插值或延迟补偿。 |
| R-TIME-004 | SHOULD | 支持统一系统时钟同步。 |

**5.2.5 调试与回放（R-DBG-*）** — 归属：core/replay

| 需求 ID | 约束 | 内容 |
|---------|------|------|
| R-DBG-001 | SHOULD | 支持数据录包。 |
| R-DBG-002 | SHOULD | 支持离线回放。 |

作用：无机器人即可调试，提升开发效率。

---

## 6. 数据流规范

统一数据流（R-ARCH-003）：

1. **comms** 接收数据  
2. **protocol** 解析  
3. 写入 **DataCenter**  
4. **service** 处理（可读事件总线、坐标变换、时间同步）  
5. **ui** 显示  

**任何模块不得绕过此流程或逆向调用。** 模块间通过事件总线（publish/subscribe）解耦，禁止直接互相调用。

---

## 7. 开发阶段规划

| 阶段 | 目标 |
|------|------|
| Phase 1：基础框架 | 完成目录结构、QtPy 主窗口可启动、DataCenter 创建 |
| Phase 2：通信打通 | MQTT 可连接、接收数据日志打印 |
| Phase 3：协议解析 | protobuf 解析成功、数据写入 DataCenter |
| Phase 4：最小可用 UI | 图传显示、血量展示 |
| Phase 5：态势界面 | 地图、机器人位置、关键状态 |
| Phase 6：控制功能 | 发送赛事指令 |
| Phase 7：插件机制 | 动态加载插件、支持后续扩展 |

---

## 8. 开发规范与非功能需求

**必须遵守：** 禁止跨层依赖；禁止大文件（单文件 >800 行必须拆分）；新功能优先新模块；公共接口必须写文档注释；重要逻辑必须可测试。

| 类别 | 要求 |
|------|------|
| **可维护性** | 单文件 ≤ 800 行；强制模块化。 |
| **可扩展性** | 新功能通过插件实现。 |
| **可交接性** | 必须配套文档（见第 9 章）。 |

---

## 9. 交接要求

项目交付时必须包含：

- **本总文档**（系统需求与架构设计，即 `docs/CustomClient_Architecture.md`）
- 赛事通信协议文档引用与所用协议版本说明（如 Protobuf 消息版本、Topic 列表）
- 模块说明
- 快速启动指南
- 示例插件
- 代码注释完整

**否则视为不可交接项目。**

---

## 10. 实现策略与验收

### 10.1 实现思路

- **按阶段做**：严格按第 7 章 Phase 1～7 顺序，先框架再通信再协议再 UI 再态势再控制再插件；每阶段完成再进下一阶段。
- **按层做**：每阶段只动当前层；通信层只做收发、协议层只做解析、数据层只做 DataCenter、业务层只做逻辑、UI 只做展示；**禁止跨层实现**（例如不在 comms 里解析 Protobuf）。
- **需求可追溯**：实现时对照本文档需求 ID（R-ARCH-001/002/003、R-COM-*、R-POSE-*、R-BUS-*、R-TIME-*、R-DBG-*）；每个 MUST 对应可检查的代码或配置。

### 10.2 如何确保需求落地

| 手段 | 做法 |
|------|------|
| **实现前** | 接到需求先查本文档：属于哪一层、哪条 R-*；若文档没有则先更新文档再写代码。 |
| **实现中** | 单文件 ≤800 行；新功能优先新模块/插件；公共接口写注释；重要逻辑可单测。 |
| **实现后** | 用「需求–实现对照表」或 checklist 逐条勾选 R-ARCH / R-COM / R-POSE / R-BUS / R-TIME / R-DBG；合入前检查是否违反 MUST、是否跨层、是否绕开 DataCenter。 |
| **回归** | 用录包/回放（R-DBG）做离线回归；关键路径（MQTT 收→解析→写 DataCenter→UI 显）有自动化或手测步骤。 |

### 10.3 谁来做、何时做

- **实现**：开发按本文档与 Phase 执行；不确定时以本文档为准，有冲突先改文档再改代码。
- **验收**：每阶段结束按 10.2 做一次自查；交接前按第 9 章交接要求与需求 checklist 做完整验收。

### 10.4 实现示例：设备间单向通信（增强说服性）

以「局域网下两设备单向通信」为例（如雷达 → 客户端）：按本文档应落在**哪一步、用哪一层、怎么实现**，便于对照执行。

| 项目 | 说明 |
|------|------|
| **阶段** | **Phase 2（通信打通）** 内一并做，或 Phase 2 只做赛事 MQTT，**Phase 2 之后**单独做一步「设备间 LAN 单向」。 |
| **层级** | **通信层（core/comms）**，对应 R-COM-001/002（局域网 UDP/TCP、单向发送）。 |
| **实现位置** | 在 `core/comms/` 下增加**设备间链路**子模块，例如 `device_link.py` 或 `lan_receiver.py`：只做单向接收（UDP/TCP 监听），收字节流、打时间戳（R-TIME-001）、打来源标识，**不解析业务协议**。若需独立可复用 Python 包，可单独包（如 `rm_device_link`），在 comms 中调用该包并把字节流/时间戳交给 protocol 或 DataCenter。 |
| **数据流** | 雷达发 UDP/TCP → **comms（device_link）** 收 → 原始字节 + 时间戳 + 来源 → **protocol**（若需则解析）→ 写入 **DataCenter** → service/UI 使用。 |

**与需求对应：** R-COM-001（UDP/TCP）→ 在 device_link 中用 socket 实现；R-COM-002（单向）→ 只做 recv；R-TIME-001（时间戳）→ 在 comms 收包时打时间戳再往下传。**禁止**在 comms 中解析业务内容（如具体业务字段），解析放在 protocol 或后续层。此例说明：新需求先定「阶段 + 层 + 模块」，再按数据流与 R-* 实现，即可保证可维护与可交接。

---

## 11. 变更与排错

### 11.1 需求或架构要改时

- **只改一处**：所有约定以**本总文档**为准；需求/架构变更只改本文档，改完再改代码。
- **改文档**：在对应章节（如 2 总体架构、5 功能需求）修改或新增条文；若新增需求则赋予新需求 ID（如 R-XXX-NNN），并标 MUST/SHOULD。
- **再改代码**：按更新后的文档改实现；合入前确认文档与代码一致。

### 11.2 出问题时怎么查、怎么改

| 现象 | 建议排查与修改方向 |
|------|---------------------|
| 数据不对 / 状态乱 | 先看是否违反 R-ARCH-002：是否有模块私存状态、UI 是否写状态；统一改为只读写 DataCenter。 |
| 界面卡顿 / 延迟大 | 看数据流是否逆向、是否在 UI 线程做重活；业务与协议处理放到 service/protocol，UI 只读 DataCenter 与事件总线。 |
| 模块间耦合难改 | 用 R-BUS：模块间只通过事件总线 publish/subscribe，禁止直接调用；新功能用插件隔离。 |
| 图传/雷达不同步 | 查 R-TIME：数据是否带时间戳、是否走缓冲与插值；时间同步在 core/time_sync 统一处理。 |
| 协议或赛事规则变更 | 更新本文档 1.5 与相关协议说明；只改 protocol 层与 .proto，不改 comms 层职责。 |
| 难以复现的 bug | 用 R-DBG 录包；用回放复现后再修，修完用同一包回归。 |

### 11.3 后续迭代原则

- **文档驱动**：先更新本总文档再写代码，避免文档与实现脱节。
- **边界清晰**：修 bug 或加功能都限定在对应层/模块内，不顺手在别的层「补一刀」。
- **可交接**：每次较大变更后更新「模块说明」或快速启动指南（若有）；重要决策记在本文档或注释里。

---

## 12. 总览与自检（规定要求、功能完整、可维护性）

以下用于确认本文档是否满足**规定的要求**与**功能的完整**，以及**可维护性**在文档中的体现位置。实现与交接前可据此自检。

### 12.1 规定的要求是否满足

| 类别 | 要求 | 文档位置 | 是否覆盖 |
|------|------|----------|----------|
| **最高约束** | 任何实现不得违反 MUST 条款 | 文首约束、§13 结论 | ✓ |
| **架构 MUST** | R-ARCH-001 六层、禁止跨层 | §2、§3 目录、§4 模块、§6 数据流 | ✓ |
| **架构 MUST** | R-ARCH-002 单一数据源 DataCenter | §2、§4.3、§6、§11.2 | ✓ |
| **架构 MUST** | R-ARCH-003 单向数据流 | §2、§6、§10.1 | ✓ |
| **设备间 MUST** | R-COM-001～005（UDP/TCP、重连、心跳、统计） | §5.2.1、§4.1、§10.4 | ✓ |
| **坐标 MUST** | R-POSE-001～004（注册表、变换、外参、接口） | §5.2.2、§4 | ✓ |
| **事件总线 MUST** | R-BUS-001～003（统一总线、publish/subscribe、禁止直接调用） | §5.2.3、§6 | ✓ |
| **时间同步 MUST** | R-TIME-001～003（时间戳、缓冲、插值/延迟补偿） | §5.2.4 | ✓ |
| **SHOULD** | R-COM-006、R-POSE-005、R-TIME-004、R-DBG-001/002 | §5.2.1～5.2.5 | ✓ |
| **技术选型** | 界面与交互采用 QtPy | 文首、§0.1、§4.5、§5.1.4 | ✓ |
| **赛事规范** | MQTT 3333、UDP 3334、Protobuf v3、HEVC、8 字节包头 | §1.5、§4.1、§4.2 | ✓ |

**结论：** 规定要求已全部在文档中写明并具可追溯位置；实现时按需求 ID 与章节对照即可。

### 12.2 功能完整性

| 功能域 | 文档位置 | 是否完整 |
|--------|----------|----------|
| **赛事数据** | §0.2、§1.5、§4.1、§5.2.1 | ✓ 接收/发送、Topic、协议 |
| **图传** | §0.2、§1.5、§4.1/4.2、§5.1、§5.1.4 | ✓ 3334、8 字节、HEVC、VideoLayer |
| **态势与状态** | §0.2、§5.1、§5.1.4、§7 Phase 5 | ✓ 血量/经济/时间/事件、地图/位置 |
| **透视框（HUD）** | §0.2、§5.1.1、§5.1.4、§0.5 | ✓ 开关、超时、断流、BoxStore/Renderer |
| **标定** | §0.2、§5.1.2、§5.2.2、§0.3 | ✓ 入口、四态、ArUco 引导、验收点 |
| **雷达与设备间** | §0.2、§5.2.1、§4.1、§10.4 | ✓ LAN、重连、心跳、统计、典型数据 |
| **诊断与联调** | §0.2、§5.1.3、§5.2.5 | ✓ 链路/数据状态、计数、一键复制、回放 |
| **控制与扩展** | §0.2、§5.1、§4.6、§7 Phase 6～7 | ✓ 赛事指令、插件机制 |
| **角色需求** | §0.4 多屏/多角色、§0.5 地面机器人操作手 | ✓ 地面手需求；雷达手可类比 §0.5 补充 |
| **产品形态** | §0.3 最终产品形态描述 | ✓ 布局、场景、非界面侧保证 |

**结论：** 基本功能与角色需求（含地面操作手）已覆盖；多屏/多角色为待定，雷达手可后续按 §0.5 形式补充。

### 12.3 可维护性体现在哪里

可维护性在本文档中通过以下**多处**显式体现，便于长期维护与跨届接手。

| 维度 | 体现位置 | 具体内容 |
|------|----------|----------|
| **目标声明** | §1.4 | 系统须满足 **Maintainability** / Extensibility / Modularity / Decoupling / Readability；定位为队伍长期基础设施。 |
| **技术选型** | 文首、§0.1 | QtPy 统一封装多 Qt 绑定，**保证跨平台与长期可维护**。 |
| **架构约束** | §2 | **分层**（改一层不影响他层）、**单一数据源**（状态不乱）、**单向数据流**（依赖清晰）；职责单一、可扩展、可交接。 |
| **目录与模块** | §3、§4 | **固定目录层级**、每层**输入/输出与禁止行为**明确，改一处边界清晰。 |
| **基础设施层** | §5.2 引言 | 缺失任意一项，**可维护性将显著下降**；故 R-COM/R-POSE/R-BUS/R-TIME/R-DBG 均为长期可维护前提。 |
| **开发规范** | §8 | **单文件 ≤ 800 行**、**强制模块化**；新功能优先新模块；公共接口文档注释；重要逻辑可测。 |
| **交接要求** | §9 | 交付须含本总文档、协议版本说明、**模块说明**、**快速启动指南**、示例插件、代码注释完整；否则视为不可交接。 |
| **实现与验收** | §10 | **按阶段/按层**实现；需求可追溯（R-*）；实现前中后检查、合入前 checklist、回归（R-DBG）。 |
| **变更与排错** | §11 | **只改一处**（本总文档）；**文档驱动**（先更文档再写代码）；**边界清晰**（修 bug/加功能限定在对应层）；可交接（大变更后更新模块说明/快速启动）。 |
| **结论** | §12 结论 | 该结构可确保**多年维护**、规则变更可适配、**新成员低成本接手**。 |

**小结：** 可维护性 = **架构分层与单一数据源**（§2、§6）+ **目录与模块边界**（§3、§4）+ **单文件与模块化**（§8）+ **交接与文档**（§9、§11）+ **需求可追溯与变更流程**（§10、§11）；文档驱动与边界清晰贯穿 §10～11。

---

## 13. 结论

本系统由**表现层**（UI / HUD / 渲染）与**基础设施层**（设备通信、坐标变换、消息总线、时间同步、调试回放）构成。采用六层分层架构、单一数据源（DataCenter）、单向数据流、模块化设计、插件式扩展。**基础设施层是长期稳定运行的核心。**

该结构可确保：多年维护、规则变更可适配、新成员低成本接手。

**任何实现不得违反本文档中 MUST 条款；任何偏离本架构的实现均不建议合入主分支。**
